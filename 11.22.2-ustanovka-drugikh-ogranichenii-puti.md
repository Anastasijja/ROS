# 11.22.2 Установка других ограничений пути

Предположим, задача робота состоит в том, чтобы захватить и переместить объект при сохранении его в вертикальном положении. Например, объектом может быть контейнер с жидкостью, такой как чашка кофе, поэтому чашка должна не опрокинуться и жидкость должна не разлиться. MoveIt! позволяет указать ограничения траектории для запланированной траектории, которые могут достичь этого типа цели.

В этом случае необходимо ограничить ориентацию захвата таким образом, чтобы он оставался на определенном уровне во время движения. Сценарий, moveit\_contraints\_demo.py в каталоге rbx2\_arm\_nav/scripts, иллюстрирует его работу. Этот сценарий выполняет следующие действия:

* Запускает руку в положение "resting"
* Перемещает руку в исходную позу с захватом вокруг высоты плеча и по горизонтали
* Создает и задает зависимость ориентации, задающую горизонтальную ориентацию захвата.
* Устанавливает целевую позу для захвата перед роботом и вниз по высоте стола
* Планирует и выполняет путь к целевой позе, удовлетворяя ограничениям ориентации;
* Устраняет ограничения
* Перемещает руку назад в положение "resting"

Имейте в виду, что, когда Вы используете ограничений пути, как начальная поза, так и целевая поза должны удовлетворять этим ограничениям, или планирование не будет выполнено.

Прежде чем посмотреть на код, попробуем запустить его. Сначала запуситм версию Робота Pi с одной рукой в симуляторе ArbotiX:

```text
$ roslaunch rbx2_bringup pi_robot_with_gripper.launch sim:=true
```

А теперь обстреляйте узлы MoveIt! для Пи:

```text
$ roslaunch pi_robot_moveit_config move_group.launch
```

Затем откройте RViz с конфигурационным файлом arm\_nav.rviz:

```text
$ rosrun rviz rviz -d `rospack find rbx2_arm_nav`/config/arm_nav.rviz
```

Наконец, запустите сценарий moveit\_contraints\_demo.py:

```text
$ rosrun rbx2_arm_nav moveit_constraints_demo.py
```

При успешном движении захват должен перемещаться вертикально вниз перед роботом, сохраняя захват горизонтальным. Вы заметите, что обычно существует довольно длительная пауза \(возможно, до 2 минут на i5\), в то время как планировщик пытается вычислить путь для захвата, который удовлетворяет ограничениям, и в некоторых случаях он полностью провалится даже после 5 попыток по умолчанию. \(Для каждой попытки в сценарии устанавливается 15 секунда времени планирования.\) Это обусловлено алгоритмом случайной выборки, который требует IK-решения для каждой точки выборки, и тем фактом, что числовой решатель KDL относительно медленный при вычислении IK-решений. К счастью, гораздо более быстрые и надежные результаты можно получить с помощью решателя IKFast, который мы изучим в конце главы.

Рассмотрим ключевые строки сценария moveit\_constraints\_demo.py:

Ссылка на источник: moveit\_constraints\_demo.py

```text
from moveit_msgs.msg import Constraints, OrientationConstraint
```

Чтобы использовать ограничения ориентации, мы сначала импортируем общий Ограничительный тип сообщения, а также сообщение OrientationConstraint из пакета сообщений MoveIt!. \(Существует также тип сообщения PosationConstraint, который работает аналогичным образом.\)

```text
# Create a contraints list and give it a name    
constraints = Constraints()    
constraints.name = "Keep gripper horizontal"         
# Create an orientation constraint for the right gripper    
orientation_constraint = OrientationConstraint()    
orientation_constraint.header = start_pose.header   
orientation_constraint.link_name = right_arm.get_end_effector_link()     orientation_constraint.orientation.w = 1.0    
orientation_constraint.absolute_x_axis_tolerance = 0.1     orientation_constraint.absolute_y_axis_tolerance = 0.1     orientation_constraint.absolute_z_axis_tolerance = 3.14    
orientation_constraint.weight = 1.0
```

Чтобы создать ограничение пути, сначала инициализируем список Constraints \(ограничения\) и присваиваем ему имя. Затем мы начинаем добавлять ограничения в список. В этом случае будет добавлено одно ограничение ориентации.

Заголовок ограничения обычно совпадает с заголовком положения руки непосредственно перед наложением ограничения.

Эта link\_name относится к связи, которую мы хотим ограничить, которая в нашем случае является захватом \(конечным эффектом\).

Затем задаем требуемую ориентацию для единицы кватерниона \(компоненты x, y и z по умолчанию равны нулю\). Единичный кватернион в рамке планирования \(base\_footprint\) относится к горизонтальной ориентации захвата для пальцев, направленных в направлении оси X \(т.е. в том же направлении, куда обращен сам робот\). Если мы просто хотим сохранить уровень захвата и нам не важно, вращается ли он вокруг оси Z во время движения, мы можем установить absolute\_z\_axis\_tolerance на 3,14 радиана, как мы сделали выше. Однако, чтобы не допустить накатывания или качания захвата вокруг осей x и y, мы устанавливаем эти допуски довольно низкими.

Наконец, мы придаем этому ограничению вес, который имел бы большую актуальность, если бы мы применяли несколько ограничений одновременно.

```text
# Append the constraint to the list of contraints     constraints.orientation_constraints.append(orientation_constraint)    
# Set the path constraints on the right_arm    
right_arm.set_path_constraints(constraints)
```

В следующих двух строках сначала добавляется ограничение ориентации к списку зависимостей, а затем, поскольку это единственное ограничение, которое мы собираемся применить, используется функция set\_path\_constraints \(\) для применения зависимостей к группе перемещения right\_arm.

```text
# Set a target pose for the arm            target_pose = PoseStamped()     target_pose.header.frame_id = REFERENCE_FRAME     target_pose.pose.position.x = 0.173187824708     target_pose.pose.position.y = -0.0159929871606     target_pose.pose.position.z = 0.692596608605     target_pose.pose.orientation.w = 1.0
# Set the start state and target pose, then plan and execute     right_arm.set_start_state_to_current_state()     right_arm.set_pose_target(target_pose, end_effector_link)     right_arm.go()     rospy.sleep(1)
```

Затем мы устанавливаем следующую целевую позицию и выполняем траекторию в обычном режиме. Плановик видит, что ограничение было применено к группе right\_arm, и поэтому включает ограничение в планирование.

```text
right_arm.clear_path_constraints()
```

При необходимости возврата к обычному планированию снимите все ограничения с помощью функции clear\_path\_constraints \(\).

